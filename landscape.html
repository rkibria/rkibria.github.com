<!doctype html>
<html>

<head>
<meta charset="utf-8">
<title></title>
<link rel="stylesheet" href="css/landscape.css">
</head>

<body>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

<script src="js/three.min.js"></script>
<script src="js/FirstPersonControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/seedrandom.min.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/threex.windowresize.js"></script>

<script>
//-------------------------------------
// CONSTS
var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;

var TERRAIN_SIZE = 10;

var TERRAIN_SEGMENTS = 4;
var TERRAIN_TRACKS = TERRAIN_SEGMENTS + 1;

var MIN_TILE_CREATE_RANGE = 15;

var MOVE_SPEED = 1.0;
var TURN_SPEED = 0.1;

//-------------------------------------
// SCENE
var scene = new THREE.Scene();

// CAMERA
var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
var camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
camera.position.x = 0;
camera.position.y = 10;
camera.position.z = 0;

// RENDERER + FOG
var FogColor = 0xffffff;
scene.fog = new THREE.FogExp2( FogColor, 0.01 );

if ( Detector.webgl )
	renderer = new THREE.WebGLRenderer( {antialias:true} );
else
	renderer = new THREE.CanvasRenderer();
renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
renderer.setClearColor( FogColor );
var container = document.getElementById( 'ThreeJS' );
container.appendChild( renderer.domElement );

// EVENTS
THREEx.WindowResize(renderer, camera);

// STATS
stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.bottom = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

// CONTROLS
var controls = new THREE.FirstPersonControls( camera );
controls.movementSpeed = 10;
controls.lookSpeed = 0.1;

// LIGHT
var light = new THREE.PointLight(0xffffff, 1, 0);
light.position.set( 0, 100, 0 );
scene.add( light );

var light2 = new THREE.AmbientLight(0x333333);
scene.add(light2);

// SKYBOX
scene.background = new THREE.CubeTextureLoader()
.setPath( 'images/' )
.load( [
"sky-px.jpg",
"sky-nx.jpg",
"sky-py.jpg",
"sky-ny.jpg",
"sky-pz.jpg",
"sky-nz.jpg"
] );

//-------------------------------------
// GUI

var TriggerTerrainReset = false;

var gui = new dat.GUI();
this.displayOutline = false;

var GuiParameters =
{
	showWireframe: false
};

var showWireframe = gui.add( GuiParameters, 'showWireframe' );
showWireframe.onChange(function(value) {
	TriggerTerrainReset = true;
});

gui.open();

//-------------------------------------

function getCurrentTerrainPos() {
	var tx = Math.floor(camera.position.x / TERRAIN_SIZE);
	var ty = Math.floor(camera.position.z / TERRAIN_SIZE);
	var tz = Math.floor(Math.sqrt(Math.abs(camera.position.y)));
	return new THREE.Vector3(tx, ty, tz);
}

function moveForward(speed) {
	camera.position.z -= speed * Math.cos(camera.rotation.y);
	camera.position.x -= speed * Math.sin(camera.rotation.y);
}

function moveUp(speed) {
	camera.position.y += speed;
}

function turnView(speed) {
	camera.rotation.y += speed;
}

function getTerrainKey(tx, ty) {
	return tx + "/" + ty;
}

function getPosFromTerrainKey(terrainKey) {
	tokens = terrainKey.split("/");
	var tx = parseInt(tokens[0]);
	var ty = parseInt(tokens[1]);
	return new THREE.Vector2(tx, ty);
}

function getTerrainHeight(x, y) {
	var heightSeed = "x" + x + "y" + y;
	Math.seedrandom(heightSeed);

	var r = Math.random();
	var z = r * 4;

	var d = Math.sqrt(x*x + y*y);
	var w = Math.sin(d / 10) * 5 + (Math.sin(x/10) + Math.cos(y/10)) * 5;

	var h = w + z;

	return h;
}

var TerrainTexture = new THREE.TextureLoader().load( "images/graystone.jpg" );
TerrainTexture.wrapS = THREE.RepeatWrapping;
TerrainTexture.wrapT = THREE.RepeatWrapping;

function generateTile(tx, ty) {
	var terrainGeometry = new THREE.PlaneGeometry( TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS );
	var index = 0;
	var bx = (tx + 0.5) * TERRAIN_SIZE;
	var by = (ty + 0.5) * TERRAIN_SIZE;
	for ( var i = 0; i < TERRAIN_TRACKS; i ++ ) {
		for ( var k = 0; k < TERRAIN_TRACKS; k ++ ) {
			var x = bx + (k / TERRAIN_SEGMENTS) * TERRAIN_SIZE;
			var y = by + ((TERRAIN_SEGMENTS - i) / TERRAIN_SEGMENTS) * TERRAIN_SIZE;
			var z = getTerrainHeight(x, y);
			terrainGeometry.vertices[index].z = z;
			index += 1;
		}
	}

	var terrainMaterial;
	if (GuiParameters.showWireframe) {
		var materialColor = (Math.abs(tx + ty) % 2) ? 0x00ff00 : 0x0000ff;
		terrainMaterial = new THREE.MeshBasicMaterial( {
			color: materialColor,
			side: THREE.DoubleSide,

			transparent: true,
			opacity: 0.9,

			polygonOffset: true,
			polygonOffsetFactor: 1,
			polygonOffsetUnits: 1
			} );
	}
	else {
		terrainMaterial = new THREE.MeshBasicMaterial( {
			map: TerrainTexture,
			side: THREE.DoubleSide
			} );
	}

	var terrainTile = new THREE.Mesh( terrainGeometry, terrainMaterial );

	if (GuiParameters.showWireframe) {
		var geo = new THREE.EdgesGeometry( terrainTile.geometry ); // or WireframeGeometry
		var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
		var wireframe = new THREE.LineSegments( geo, mat );
		terrainTile.add( wireframe );
	}

	var waterGeometry = new THREE.PlaneGeometry( TERRAIN_SIZE, TERRAIN_SIZE );
	var waterMaterial = new THREE.MeshPhongMaterial( {
			color: 0x0000ff,
			side: THREE.DoubleSide,
			transparent: true,
			opacity: 0.5,
			wireframe: GuiParameters.showWireframe
			});
	var waterMesh = new THREE.Mesh( waterGeometry, waterMaterial );
	terrainTile.add( waterMesh );

	terrainTile.position.x = (tx + 0.5) * TERRAIN_SIZE;
	terrainTile.position.y = 0;
	terrainTile.position.z = (ty + 0.5) * TERRAIN_SIZE;
	terrainTile.rotation.x = Math.PI/2;
	terrainTile.name = getTerrainKey(tx, ty);

	scene.add( terrainTile );

	return terrainTile;
}

var LastTerrainPos = null;
var TerrainTiles = new Map();

function removeTerrain(terrainKey) {
	var terrainValue = TerrainTiles[terrainKey];
	scene.remove(scene.getObjectByName(terrainKey));
	TerrainTiles.delete(terrainKey);
}

function deleteTiles(curTpos, tileDeleteRange) {
	toDelete = [];
	for (var terrainKey of TerrainTiles.keys()) {
		var tpos = getPosFromTerrainKey(terrainKey);
		if (Math.abs(tpos.x - curTpos.x) > tileDeleteRange || Math.abs(tpos.y - curTpos.y) > tileDeleteRange) {
			toDelete.push(terrainKey);
		}
	}

	if (toDelete.length > 0) {
		dLen = toDelete.length;
		for (i = 0; i < dLen; i++) {
			var terrainKey = toDelete[i];
			removeTerrain(terrainKey);
		}
	}
}

function createTiles(curTpos, tileCreateRange) {
	for (tx = curTpos.x - tileCreateRange; tx <= curTpos.x + tileCreateRange; tx++) {
		for (ty = curTpos.y - tileCreateRange; ty <= curTpos.y + tileCreateRange; ty++) {
			var terrainKey = getTerrainKey(tx, ty);
			if (!TerrainTiles.has(terrainKey)) {
				var terrainValue = generateTile(tx, ty);
				TerrainTiles.set(terrainKey, terrainValue);
			}
		}
	}
}

function updateTerrain() {
	var curTpos = getCurrentTerrainPos();
	if (!TriggerTerrainReset && (LastTerrainPos !== null && curTpos.equals(LastTerrainPos)))
		return;

	var tileCreateRange = MIN_TILE_CREATE_RANGE + curTpos.z;

	var tileDeleteRange = tileCreateRange; // + 1; // When debugging don't add 1 to see pop-in and out easier
	if (TriggerTerrainReset) {
		tileDeleteRange = -1;
	}

	deleteTiles(curTpos, tileDeleteRange);

	var t0 = performance.now();
	createTiles(curTpos, tileCreateRange);
	var t1 = performance.now();
	// console.log("createTiles(): " + (t1 - t0) + " ms")

	LastTerrainPos = getCurrentTerrainPos();

	TriggerTerrainReset = false;
}

var clock = new THREE.Clock();

var render = function () {
	requestAnimationFrame( render );
	stats.update();

	updateTerrain();

	controls.update( clock.getDelta() );
	renderer.render(scene, camera);
};

render();

</script>

</body>

</html>
