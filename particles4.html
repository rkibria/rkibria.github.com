<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8">
<title>Particle flurry</title>
</head>

<body>

<canvas id="canvas" width="800" height="800" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>

var CSS_COLOR_NAMES = ["AliceBlue","AntiqueWhite","Aqua","Aquamarine","Azure","Beige","Bisque","BlanchedAlmond","Blue","BlueViolet","Brown","BurlyWood","CadetBlue","Chartreuse","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","DarkBlue","DarkCyan","DarkGoldenRod","DarkGray","DarkGrey","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","Darkorange","DarkOrchid","DarkRed","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkSlateGrey","DarkTurquoise","DarkViolet","DeepPink","DeepSkyBlue","DimGray","DimGrey","DodgerBlue","FireBrick","FloralWhite","ForestGreen","Fuchsia","Gainsboro","GhostWhite","Gold","GoldenRod","Gray","Grey","Green","GreenYellow","HoneyDew","HotPink","IndianRed","Indigo","Ivory","Khaki","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenRodYellow","LightGray","LightGrey","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSlateGrey","LightSteelBlue","LightYellow","Lime","LimeGreen","Linen","Magenta","Maroon","MediumAquaMarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","Navy","OldLace","Olive","OliveDrab","Orange","OrangeRed","Orchid","PaleGoldenRod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","Pink","Plum","PowderBlue","Purple","Red","RosyBrown","RoyalBlue","SaddleBrown","Salmon","SandyBrown","SeaGreen","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","SlateGrey","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Tomato","Turquoise","Violet","Wheat","White","WhiteSmoke","Yellow","YellowGreen"];

/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 */
function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Keeps track of the current mouse position, relative to an element.
 * @param {HTMLElement} element
 * @return {object} Contains properties: x, y, event
 */
function captureMouse(element) {
  var mouse = {x: 0, y: 0, event: null},
	  body_scrollLeft = document.body.scrollLeft,
	  element_scrollLeft = document.documentElement.scrollLeft,
	  body_scrollTop = document.body.scrollTop,
	  element_scrollTop = document.documentElement.scrollTop,
	  offsetLeft = element.offsetLeft,
	  offsetTop = element.offsetTop;
  
  element.addEventListener('mousemove', function (event) {
	var x, y;
	
	if (event.pageX || event.pageY) {
	  x = event.pageX;
	  y = event.pageY;
	} else {
	  x = event.clientX + body_scrollLeft + element_scrollLeft;
	  y = event.clientY + body_scrollTop + element_scrollTop;
	}
	x -= offsetLeft;
	y -= offsetTop;
	
	mouse.x = x;
	mouse.y = y;
	mouse.event = event;
  }, false);
  
  return mouse;
};

///////////////////////////////////////////////////////////////////////////////
const canvas = document.getElementById('canvas');
const canvasW = canvas.scrollWidth, canvasH = canvas.scrollHeight;

///////////////////////////////////////////////////////////////////////////////
function Particle(radius, color) {
	if (radius === undefined) { radius = 40; }
	if (color === undefined) { color = "#ff0000"; }
	this.x = 0;
	this.y = 0;
	this.radius = radius;
	this.vx = 0;
	this.vy = 0;
	this.mass = 1;
	this.scaleX = 1;
	this.scaleY = 1;
	this.color = color;
	this.lineWidth = 0;
}

Particle.prototype.draw = function (context) {
	context.save();
	context.translate(this.x, this.y);
	context.scale(this.scaleX, this.scaleY);

	context.lineWidth = this.lineWidth;
	context.fillStyle = this.color;
	context.beginPath();
	context.arc(0, 0, this.radius, 0, (Math.PI * 2), true);
	context.closePath();
	context.fill();
	if (this.lineWidth > 0) {
		context.stroke();
	}
	context.restore();
};

///////////////////////////////////////////////////////////////////////////////
function ParticleSwarm(count, width, height) {
	this.particles_list = [];
	this.width = width;
	this.height = height;

	this.friction = 0.999;
	this.gravitational = 0.01;
	this.fall_speed = 0.001;

	for (i = 0; i < count; i++) {
		var particle = new Particle(3, CSS_COLOR_NAMES[i % CSS_COLOR_NAMES.length]);
		particle.x = Math.random() * this.width;
		particle.y = Math.random() * this.height;
		particle.vx = Math.random() * 5 - 3;
		particle.vy = Math.random() * 5 - 3;
		particle.mass = 100;
		this.particles_list.push(particle);
	}
}

ParticleSwarm.prototype.get_distance = function(p1, p2) {
	var xsq = p1.x - p2.x
	xsq = xsq * xsq
	var ysq = p1.y - p2.y
	ysq = ysq * ysq
	return Math.sqrt(xsq + ysq);
};

ParticleSwarm.prototype.get_force = function(p1, p2) {
	let fx = 0, fy =  0;
	let r = this.get_distance(p1, p2);

	const touch_distance = p1.radius + p2.radius + 0;
	if (r < touch_distance) {
		r = touch_distance + 1;
		const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
		const force = this.gravitational * p1.mass * p2.mass * -1 / Math.pow(r - touch_distance, 2);
		fx = force * Math.cos(angle);
		fy = force * Math.sin(angle);
	}

	fy += this.fall_speed;

	return [fx, fy];
};

ParticleSwarm.prototype.move = function(particle) {
	particle.vx *= this.friction;
	particle.vy *= this.friction;

	particle.x += particle.vx;
	particle.y += particle.vy;

	particle.x = particle.x % this.width;
	if(particle.x < 0)
		particle.x += this.width;
	particle.y = particle.y % this.height;
	if(particle.y < 0)
		particle.y += this.height;
};

ParticleSwarm.prototype.attract_to = function(p1, p2) {
	const m1 = p1.mass;
	const force = this.get_force(p1, p2);
	p1.vx += force[0] / m1; // a = F/m
	p1.vy += force[1] / m1;

	p1.vx = Math.min(10, p1.vx);
	p1.vy = Math.min(10, p1.vy);
};

ParticleSwarm.prototype.mutually_attract = function(p1, p2) {
	this.attract_to(p1, p2);
	this.attract_to(p2, p1);
};

ParticleSwarm.prototype.draw = function(context) {
	for (i = 0; i < this.particles_list.length; i++) {
		for (j = i + 1; j < this.particles_list.length; j++) {
			this.mutually_attract(this.particles_list[i], this.particles_list[j]);
		}
	}

	const this_instance = this;
	this.particles_list.forEach(function(particle) {this_instance.move(particle);});
	this.particles_list.forEach(function(particle) {particle.draw(context);});
};

///////////////////////////////////////////////////////////////////////////////
const particles = new ParticleSwarm(500, canvasW, canvasH);

window.onload = function() {
	var canvas = document.getElementById('canvas'),
	context = canvas.getContext('2d');

	(function drawFrame () {
		window.requestAnimationFrame(drawFrame, canvas);
		context.fillStyle = "black";
		context.fillRect(0, 0, canvasW, canvasH);

		particles.draw(context);
	}());
}

</script>

</body>
</html>
