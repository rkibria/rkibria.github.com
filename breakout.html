<!doctype html>
<html>

<head>
<meta charset="utf-8">
<title>Three.js Breakout</title>
</head>

<body>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/threex.windowresize.js"></script>

<script>
"use strict";

// CONSTS
const BORDER_X = 8;
const BALL_RADIUS = 0.3;
const BORDER_Z = 30;

const SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;

// SCENE
const scene = new THREE.Scene();

// CAMERA
const VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
const camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
camera.position.x = 0;
camera.position.y = 3;
camera.position.z = 10;

// RENDERER
let renderer = null;
if ( Detector.webgl )
	renderer = new THREE.WebGLRenderer( {antialias:true} );
else
	renderer = new THREE.CanvasRenderer();
renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
const container = document.getElementById( 'ThreeJS' );
container.appendChild( renderer.domElement );

renderer.shadowMapEnabled = true;
renderer.shadowMapType = THREE.PCFShadowMap;

// EVENTS
THREEx.WindowResize(renderer, camera);

// STATS
const stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.bottom = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

// LIGHT
const ambLight = new THREE.AmbientLight(0x555555);
scene.add(ambLight);

var spotLight = new THREE.SpotLight( 0xffffff );
spotLight.position.set( 0, 40, -30 );
spotLight.angle = Math.PI / 7;
spotLight.distance = 100;
spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 512;
spotLight.shadow.mapSize.height = 512;
spotLight.shadow.camera.near = 1;
spotLight.shadow.camera.far = 100;
spotLight.shadow.camera.fov = 30;
spotLight.target.position.set(0, 0, -20);
scene.add( spotLight );
scene.add( spotLight.target );

// GEOMETRY
const groundPlane = new THREE.Mesh(
	new THREE.PlaneGeometry( 2.5*BORDER_X, 2.5*BORDER_Z ),
	new THREE.MeshStandardMaterial( {color: 0xa0a0a0, dithering: true} )
	);
groundPlane.position.y = -0.75;
groundPlane.rotation.x = -Math.PI/2;
groundPlane.receiveShadow = true;
scene.add( groundPlane );

const ball = new THREE.Mesh( new THREE.SphereGeometry( BALL_RADIUS, 16, 16 ), new THREE.MeshLambertMaterial( {color: 0xf00000} ) );
ball.castShadow = true;
scene.add( ball );

const bat = new THREE.Mesh( new THREE.BoxGeometry( 2, 0.5, 1 ), new THREE.MeshLambertMaterial( {color: 0xf0f0f0} ) );
bat.castShadow = true;
scene.add( bat );

const leftBorder = new THREE.Mesh( new THREE.BoxGeometry( 0.25, 0.5, 30 ), new THREE.MeshLambertMaterial( {color: 0x606060} ) );
leftBorder.position.x = -BORDER_X;
leftBorder.position.z = -15;
leftBorder.castShadow = true;
scene.add( leftBorder );

const rightBorder = new THREE.Mesh( new THREE.BoxGeometry( 0.25, 0.5, 30 ), new THREE.MeshLambertMaterial( {color: 0x606060} ) );
rightBorder.position.x = BORDER_X;
rightBorder.position.z = -15;
rightBorder.castShadow = true;
scene.add( rightBorder );

const topBorder = new THREE.Mesh( new THREE.BoxGeometry( 16, 0.5, 0.25 ), new THREE.MeshLambertMaterial( {color: 0x606060} ) );
topBorder.position.z = -BORDER_Z;
topBorder.castShadow = true;
scene.add( topBorder );

// GAME DATA
let batX = 0;
const ballSpeed = new THREE.Vector2();

function resetBall() {
	ballSpeed.x = 8;
	ballSpeed.y = -8;
	ball.position.x = -BORDER_X/2 + Math.random() * BORDER_X;
	ball.position.z = -3;
}
resetBall();

// MOUSE
function onMouseMove(e) {
	let x = e.pageX;
	const margin = window.innerWidth / 4;
	x = Math.max(margin, x);
	x = Math.min(window.innerWidth - margin, x);
	batX = (x - margin) / (window.innerWidth - 2 * margin);
}

window.onload = function() {
	this.addEventListener('mousemove', onMouseMove);
}

// RENDER LOOP
var clock = new THREE.Clock();
function render() {
	requestAnimationFrame( render );
	stats.update();
	const deltaT = clock.getDelta();

	bat.position.x = -6.5 + 13 * batX;

	// Move ball
	ball.position.x += ballSpeed.x * deltaT;
	ball.position.z += ballSpeed.y * deltaT;
	const maxRight = BORDER_X - BALL_RADIUS;
	const maxLeft = -BORDER_X + BALL_RADIUS;
	if (ball.position.x > maxRight) {
		ball.position.x = maxRight;
		ballSpeed.x *= -1;
	}
	else if (ball.position.x < maxLeft) {
		ball.position.x = maxLeft;
		ballSpeed.x *= -1;
	}
	const maxTop = -BORDER_Z + BALL_RADIUS;
	if (ball.position.z < maxTop) {
		ball.position.z = maxTop;
		ballSpeed.y *= -1;
	}
	else if (ball.position.z > 3) {
		resetBall();
	}

	renderer.render(scene, camera);
};
render();

</script>

</body>

</html>
