<!DOCTYPE html>
<html>
<body>

<script src="js/three.min.js"></script>

<canvas id="myCanvas" width="300" height="300" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>

var SCREEN_WIDTH = 300;
var SCREEN_HEIGHT = 300;

var scene = {
	camera: {
		pos: new THREE.Vector3(0, 0, 0),
		point: new THREE.Vector3(0, 0, -10),
		fov: 45.0
		},

	objects: [
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, -0.5, -5), 0.8)
		},
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, 0.5, -5), 0.5)
		},
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, 0.5, -4.5), 0.1)
		},
		{
			shape: "plane",
			geometry: new THREE.Plane(new THREE.Vector3(0.0, 1.0, 0.0), 1.0)
		},
		],

	light: new THREE.Vector3(10, 10, 10),
};

var VECTOR_UP = new THREE.Vector3(0, 1, 0);

var eyeVector = new THREE.Vector3();
eyeVector.subVectors(scene.camera.point, scene.camera.pos).normalize();
console.log("eyeVector", eyeVector);

var eyeRightVector = new THREE.Vector3();
eyeRightVector.crossVectors(eyeVector, VECTOR_UP).normalize();
console.log("eyeRightVector", eyeRightVector);

var eyeUpVector = new THREE.Vector3();
eyeUpVector.crossVectors(eyeRightVector, eyeVector).normalize();
console.log("eyeUpVector", eyeUpVector);

var fovRadians = Math.PI * (scene.camera.fov / 2) / 180,
heightWidthRatio = SCREEN_WIDTH / SCREEN_HEIGHT,
halfWidth = Math.tan(fovRadians),
halfHeight = heightWidthRatio * halfWidth,
camerawidth = halfWidth * 2,
cameraheight = halfHeight * 2,
pixelWidth = camerawidth / (SCREEN_WIDTH - 1),
pixelHeight = cameraheight / (SCREEN_HEIGHT - 1);


var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.fillStyle="black";
ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

var imgData = ctx.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
console.log(imgData.data.length);

var i;
var xcomp = new THREE.Vector3();
var ycomp = new THREE.Vector3();
var rayDirection = new THREE.Vector3();
var lightVector = new THREE.Vector3();
var reflectVector = new THREE.Vector3();
var cameraVector = new THREE.Vector3();
var color = new THREE.Vector3();
var eyeRay = new THREE.Ray();
var lighting = 0;
var diffuseLight = 0, specularLight = 0;

// Lighting options
var ambientLight = new THREE.Vector3(0.05, 0.05, 0.05);
//var ambientLight = new THREE.Vector3(0.0, 0.0, 0.0);
var specularExponent = 10, diffuseFactor = 0.3;
//var specularExponent = 50, diffuseFactor = 0.1;
var specularFactor = 0.9;
var lightIntensity = 1.0;

var rayIntersection = {
	isIntersection: false,
	intersectionPoint: new THREE.Vector3(),
	surfaceNormal: new THREE.Vector3(),
	};

function getNearestIntersection(ray, result) {
	result.isIntersection = false;
	var minDist = Infinity;
	var curIntersection = new THREE.Vector3();
	var isIntersection = null;

	var objectsLength = scene.objects.length;
	var i;
	for (i = 0; i < objectsLength; i++) {
		var curObject = scene.objects[i];
		var curShape = curObject.shape;
		var curGeometry = curObject.geometry;

		if (curShape == "sphere")
			isIntersection = ray.intersectSphere(curGeometry, curIntersection);
		else if (curShape == "plane")
			isIntersection = ray.intersectPlane(curGeometry, curIntersection);
		else {
			console.log("Unknown shape", curShape);
			isIntersection = null;
		}

		if (isIntersection != null) {
			result.isIntersection = true;

			var curDist = curIntersection.lengthSq();
			if (curDist < minDist) {
				minDist = curDist;
				result.intersectionPoint.copy(curIntersection);

				if (curShape == "sphere") {
					// Compute sphere surface normal by getting vector from sphere centre to intersect
					result.surfaceNormal.copy(result.intersectionPoint);
					result.surfaceNormal.sub(curGeometry.center).normalize();
				}
				else if (curShape == "plane") {
					result.surfaceNormal.copy(curGeometry.normal);
				}
			}
		}
	}
}

for (i = 0; i < imgData.data.length; i += 4) {
	var x = (i / 4) % SCREEN_WIDTH;
	var y = SCREEN_HEIGHT - (i / (4 * SCREEN_HEIGHT));

	// Set up current eye ray
	xcomp.copy(eyeRightVector);
	xcomp.multiplyScalar((x * pixelWidth) - halfWidth);

	ycomp.copy(eyeUpVector);
	ycomp.multiplyScalar((y * pixelHeight) - halfHeight);

	rayDirection.copy(eyeVector);
	rayDirection.add(xcomp);
	rayDirection.add(ycomp).normalize();

	eyeRay.set(scene.camera.pos, rayDirection);

	// Clear color
	color.setScalar(0);

	// Get nearest intersection point
	getNearestIntersection(eyeRay, rayIntersection);

	if (rayIntersection.isIntersection) {
		// APPLY AMBIENT LIGHTING
		color.add(ambientLight);

		// GET LIGHTING STRENGTH

		// Compute vector to light source
		lightVector.copy(scene.light);
		lightVector.sub(rayIntersection.intersectionPoint).normalize();

		// Compute reflected light vector
		reflectVector.copy(lightVector);
		reflectVector.reflect(rayIntersection.surfaceNormal).normalize();

		// Compute camera / viewpoint vector
		cameraVector.copy(rayIntersection.intersectionPoint);
		cameraVector.sub(scene.camera.pos).normalize();

		// Be aware that cos can be negative, which makes no sense here as light contribution
		diffuseLight = lightIntensity * diffuseFactor * Math.max(0, rayIntersection.surfaceNormal.dot(lightVector));

		specularLight = lightIntensity * Math.max(0, cameraVector.dot(reflectVector)); // specular lighting
		specularLight = specularFactor * Math.pow(specularLight, specularExponent);

		lighting = diffuseLight + specularLight;

		color.x += lighting;
		color.y += lighting;
		color.z += lighting;
	}

	imgData.data[i] = Math.max(0, Math.min(255, color.x * 255));
	imgData.data[i+1] = Math.max(0, Math.min(255, color.y * 255));
	imgData.data[i+2] = Math.max(0, Math.min(255, color.z * 255));
	imgData.data[i+3] = 255;
}

ctx.putImageData(imgData, 0, 0);

</script>

</body>
</html>
