<!DOCTYPE html>
<html>
<body>

<script src="js/three.min.js"></script>

<canvas id="myCanvas" width="500" height="500" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>
var canvas = document.getElementById("myCanvas");

// https://stackoverflow.com/questions/4032179/how-do-i-get-the-width-and-height-of-a-html5-canvas
var SCREEN_WIDTH = canvas.scrollWidth;
var SCREEN_HEIGHT = canvas.scrollHeight;
console.log("Canvas size", SCREEN_WIDTH, "x", SCREEN_HEIGHT, "=", SCREEN_WIDTH * SCREEN_HEIGHT, "rays");

var VECTOR_UP = new THREE.Vector3(0, 1, 0);

var scene = {
	camera: {
		pos: new THREE.Vector3(0, 0, 0),
		point: new THREE.Vector3(0, 0, -10),
		fov: 45.0
		},

	objects: [
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, -0.5, -5), 0.8)
		},
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, 0.5, -5), 0.5)
		},
		{
			shape: "sphere",
			geometry: new THREE.Sphere(new THREE.Vector3(0, 0.5, -4.5), 0.1)
		},
		{
			shape: "plane",
			geometry: new THREE.Plane(new THREE.Vector3(0.0, 1.0, 0.0), 1.0)
		},
		],

	ambientLight: new THREE.Vector3(0.05, 0.05, 0.05),
	specularExponent: 10,
	diffuseFactor: 0.3,
	specularFactor: 0.9,
	lightIntensity: 1.0,

	light: new THREE.Vector3(10, 10, 10),

	view: {
		eyeVector: new THREE.Vector3(),
		eyeRightVector: new THREE.Vector3(),
		eyeUpVector: new THREE.Vector3(),

		halfWidth: 0,
		halfHeight: 0,
		pixelWidth: 0,
		pixelHeight: 0,

		eyeRay: new THREE.Ray(),

		xcomp: new THREE.Vector3(),
		ycomp: new THREE.Vector3(),
		rayDirection: new THREE.Vector3(),
	},
	
	render: {
		lightVector: new THREE.Vector3(),
		reflectVector: new THREE.Vector3(),
		cameraVector: new THREE.Vector3(),
		color: new THREE.Vector3(),
	},
};

var rayIntersection = {
	isIntersection: false,
	intersectionPoint: new THREE.Vector3(),
	surfaceNormal: new THREE.Vector3(),
	};

function getNearestIntersection(ray, result) {
	result.isIntersection = false;
	var minDist = Infinity;
	var curIntersection = new THREE.Vector3();
	var isIntersection = null;

	var objectsLength = scene.objects.length;
	for (var i = 0; i < objectsLength; i++) {
		var curObject = scene.objects[i];
		var curShape = curObject.shape;
		var curGeometry = curObject.geometry;

		if (curShape == "sphere")
			isIntersection = ray.intersectSphere(curGeometry, curIntersection);
		else if (curShape == "plane")
			isIntersection = ray.intersectPlane(curGeometry, curIntersection);
		else {
			console.log("Unknown shape", curShape);
			isIntersection = null;
		}

		if (isIntersection != null) {
			result.isIntersection = true;

			var curDist = curIntersection.lengthSq();
			if (curDist < minDist) {
				minDist = curDist;
				result.intersectionPoint.copy(curIntersection);

				if (curShape == "sphere") {
					// Compute sphere surface normal by getting vector from sphere centre to intersect
					getNormalizedVectorFromTo (result.surfaceNormal, curGeometry.center, result.intersectionPoint);
				}
				else if (curShape == "plane") {
					result.surfaceNormal.copy(curGeometry.normal);
				}
			}
		}
	}
}

function getEyeRay(scene, x, y) {
	scene.view.xcomp.copy(scene.view.eyeRightVector);
	scene.view.xcomp.multiplyScalar((x * scene.view.pixelWidth) - scene.view.halfWidth);

	scene.view.ycomp.copy(scene.view.eyeUpVector);
	scene.view.ycomp.multiplyScalar((y * scene.view.pixelHeight) - scene.view.halfHeight);

	scene.view.rayDirection.copy(scene.view.eyeVector);
	scene.view.rayDirection.add(scene.view.xcomp);
	scene.view.rayDirection.add(scene.view.ycomp).normalize();

	scene.view.eyeRay.set(scene.camera.pos, scene.view.rayDirection);
}

function getNormalizedVectorFromTo(resultVector, startVector, endVector) {
	resultVector.copy(endVector);
	resultVector.sub(startVector).normalize();
}

function render(scene, imgData) {
	scene.view.eyeVector.subVectors(scene.camera.point, scene.camera.pos).normalize();
	scene.view.eyeRightVector.crossVectors(scene.view.eyeVector, VECTOR_UP).normalize();
	scene.view.eyeUpVector.crossVectors(scene.view.eyeRightVector, scene.view.eyeVector).normalize();

	var fovRadians = Math.PI * (scene.camera.fov / 2) / 180;
	scene.view.halfWidth = Math.tan(fovRadians);

	var heightWidthRatio = SCREEN_WIDTH / SCREEN_HEIGHT;
	scene.view.halfHeight = heightWidthRatio * scene.view.halfWidth;

	var camerawidth = scene.view.halfWidth * 2;
	var cameraheight = scene.view.halfHeight * 2;
	scene.view.pixelWidth = camerawidth / (SCREEN_WIDTH - 1);
	scene.view.pixelHeight = cameraheight / (SCREEN_HEIGHT - 1);

	var color = scene.render.color;

	for (var i = 0; i < imgData.data.length; i += 4) {
		var x = (i / 4) % SCREEN_WIDTH;
		var y = SCREEN_HEIGHT - (i / (4 * SCREEN_HEIGHT));

		getEyeRay(scene, x, y);

		// Clear color
		color.setScalar(0);

		// Get nearest intersection point
		getNearestIntersection(scene.view.eyeRay, rayIntersection);

		if (rayIntersection.isIntersection) {
			// APPLY AMBIENT LIGHTING
			color.add(scene.ambientLight);

			// GET LIGHTING STRENGTH

			var lightVector = scene.render.lightVector;
			var reflectVector = scene.render.reflectVector;
			var cameraVector = scene.render.cameraVector;

			getNormalizedVectorFromTo (lightVector, rayIntersection.intersectionPoint, scene.light);
			getNormalizedVectorFromTo (cameraVector, scene.camera.pos, rayIntersection.intersectionPoint);

			// Compute reflected light vector: from intersect to light, normalized
			reflectVector.copy(lightVector);
			reflectVector.reflect(rayIntersection.surfaceNormal).normalize();

			// Be aware that cos can be negative, which makes no sense here as light contribution
			var diffuseLight = scene.lightIntensity * scene.diffuseFactor * Math.max(0, rayIntersection.surfaceNormal.dot(lightVector));

			// Specular: how much reflected light from the sourcce goes towards the camera
			var specularLight = scene.lightIntensity * Math.max(0, cameraVector.dot(reflectVector));
			specularLight = scene.specularFactor * Math.pow(specularLight, scene.specularExponent);

			var lighting = diffuseLight + specularLight;

			color.x += lighting;
			color.y += lighting;
			color.z += lighting;
		}

		imgData.data[i] = Math.max(0, Math.min(255, color.x * 255));
		imgData.data[i+1] = Math.max(0, Math.min(255, color.y * 255));
		imgData.data[i+2] = Math.max(0, Math.min(255, color.z * 255));
		imgData.data[i+3] = 255;
	}
}

// Get canvas bitmap
var ctx = canvas.getContext("2d");
ctx.fillStyle="black";
ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
var imgData = ctx.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

var t0 = performance.now();
render(scene, imgData);
var t1 = performance.now();
console.log("render time: " + (t1 - t0) + " ms");

ctx.putImageData(imgData, 0, 0);

</script>

</body>
</html>
